# 브라우저 렌더링 과정
브라우저의 렌더링 환경을 이해하면 더 효율적인 자바스크립트 프로그래밍이 가능하다. 간략하게 다음의 과정을 거쳐 렌더링을 수행한다.

1. 브라우저는 서버에 리소스를 요청하고 응답받는다.
2. 렌더링 엔진은 한 줄씩 순차적으로 읽어 들이면서 파싱하는데 HTML을 DOM으로, CSS를 CSSOM으로 생성하고 이를 결합하여 렌더트리를 만든다.
3. 자바스크립트 엔진은 자바스크립트를 파싱하여 바이트코드로 변환하여 실행한다. 이 때 DOM API를 통해 DOM이나 CSSOM을 조작하면, 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 페인팅한다.

## URL 입력
 - 브라우저 주소창에 https://google.com 을 입력하고 엔터 키를 누르면 URL의 호스트 이름이 DNS 를 통해 IP주소로 변환되고 이 IP주소를 갖는 서버에게 요청을 전송한다.
 - 이때 루트 요청에 대해 서버는 암묵적으로 index.html을 응답한다.
 - 반드시 브라우저 주소창을 통해 서버에게 정적 파일만 요청할 수 있는 것은 아니다. 자바스크립트를 통해 동적으로 서버에 정적/동적 데이터를 요청할 수도 있다.

## HTML 파싱과 DOM 생성
- 응답된 HTML 문서는 순수한 텍스트이다. 이를 브라우저가 이해할 수 있는 자료구조로 변환하여 메모리에 저장해야 한다. 따라서 HTML 문서를 파싱해서 DOM을 생성하는 것이다.

1. 서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.
2. 브라우저는 **바이트(2진수) 형태의 HTML 문서**를 받아서 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식(예: UTF-8)으로 **문자열**로 변환한다.
3. 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 **토큰**들로 분해한다.
4. 각 토큰의 내용에 따라 객체로 변환하여 **노드**들을 생성한다.
   - 문서 노드
   - 요소 노드
   - 어트리뷰트 노드
   - 텍스트 노드
5. HTML은 요소 간의 부자 관계인 중첩 관계를 갖는데 이를 반영하여 모든 노드들을 **트리 구조**로 구성하여 **DOM(Document Object Model)** 을 만든다.

> 바이트 → 문자 → 토큰 → 노드 → DOM

## CSS 파싱과 CSSOM 생성
- 렌더링 엔진은 HTML 문서를 처음부터 한 줄씩 순차적으로 파싱하여 DOM 을 생성해 나가는데, CSS를 로드하는 link 태그나 style 태그를 만나면 DOM 생성을 일시 중단한다.
- 그리고 link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청하여 응답받으면 HTML과 동일한 파싱 과정을 거치며 CSSOM 을 생성한다.
- CSSOM 생성이 끝나면 이어서 DOM 생성을 이어나간다.

1. 서버로부터 응답된 CSS파일을 **바이트 → 문자 → 토큰 → 노드 → CSSOM** 의 과정을 거쳐 **CSSOM** 을 만든다.
2. CSSOM은 CSS의 상속의 개념을 반영하여 생성되는데, body 요소에 font-size가 12px 라면 모든 하위 요소에도 상속되어 적용된다.

> 바이트 → 문자 → 토큰 → 노드 → CSSOM

## 자바스크립트 파싱
- 렌더링 엔진은 HTML 문서를 한 줄씩 순차적으로 파싱하다가 자바스크립트 파일을 로드하는 script 태그를 만나면 DOM 생성을 일시 중단한다.
- script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 응답 받으면 자바스크립트 코드를 파싱하기 위해 **자바스크립트 엔진에게 제어권을 넘긴다.**
- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생한다. 따라서 body 요소 아래에 자바스크립트를 위치시키는 것이 좋다.
- 자바스크립트 파싱이 끝나면 **렌더링 엔진으로 다시 제어권을 넘기고** DOM 생성을 이어나간다.

1. **자바스크립트 코드**를 토크나이저가 어휘 분석하여 문법적 의미를 갖는 코드의 최소 단위인 **토큰**들로 분해하는데 이것을 토큰나이징이라 한다.
2. 파서가 토큰들을 구문 분석하여 **AST** (Abstract Syntax Tree: 추상적 구문 트리)로 파싱한다.
3. 바이트코드 생성기가 AST를 **바이트코드** 로 변환한다.
4. 인터프리터에 의해 바이트코드가 **실행** 된다.

> 자바스크립트 코드 → 토큰 → AST → 바이트코드 → 실행
   
## 렌더 트리 생성
- 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 CSSOM을 생성하고 렌더링을 위한 **렌더 트리**로 결합된다.
- 브라우저 화면에 렌더링 되지 않는 노드(예: meta 태그, script 태그)와 CSS에 의해 비표시(예: display: none;)되는 노드들은 포함되지 않는다.

## 레이아웃 계산
- 브라우저의 뷰포트(Viewport: 브라우저에서 페이지가 그려지는 영역) 내에서 렌더트리 노드들이 가지고 있는 스타일과 속성에 따라서 브라우저 화면에 어떻게 그릴지 정확한 위치와 크기를 계산한다.
- %, vw, vh 와 같은 단위들이 뷰포트 크기에 맞게 픽셀 단위로 변환된다.

## 페인트 처리
- 브라우저 화면에 실제 노드들이 픽셀 단위로 나타나도록 렌더 트리가 페인팅 처리에 입력 되도록 paint 메서드가 호출된다.

## 리플로우와 리페인트
- 만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우, 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 **레이아웃 계산**이나 **페인트 처리**를 하게 되는데 이를 **리플로우**, **리페인트**라 한다.
- 리플로우는 레이아웃을 다시 계산하는 것을 말하는데 색상이 아닌 즉, 노드의 추가나 삭제, **크기**나 **위치**를 다시 계산하는 것을 말한다.
- 리페인트는 레이아웃에 영향이 없는 경우, 예를 들어 색상이 바뀐 경우 리플로우 없이 실행 될 수 있다.


